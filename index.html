<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D äº’å‹•ç”Ÿæ—¥ç¨‹å¼ (ä¸­å¿ƒé–å®šç’°ç¹)</title>
    <!-- è¼‰å…¥ Tailwind CSS for quick styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Three.js å‡½å¼åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- è¼‰å…¥ Tone.js for web audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <style>
        /* è¨­å®šç¶²é èƒŒæ™¯å’Œå­—é«” */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* æ·±è‰²èƒŒæ™¯ */
            overflow: hidden; /* é˜²æ­¢æ»¾å‹• */
        }
        /* Canvas æ¨£å¼ï¼Œè®“å®ƒå¡«æ»¿è¦–çª— */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* åˆå§‹éš±è—ï¼Œç›´åˆ° CLI çµæŸ */
        }
        /* æ¨¡æ“¬ CLI çš„æ–‡å­—å‹•ç•«æ•ˆæœ */
        #cli-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            color: #00ff00; /* ç¶“å…¸ç¶ è‰²çµ‚ç«¯æ©Ÿæ–‡å­— */
            font-family: monospace;
            padding: 20px;
            font-size: clamp(1rem, 5vw, 2rem);
            white-space: pre-wrap;
            z-index: 100;
        }
        /* æ¸¸æ¨™é–ƒçˆå‹•ç•« */
        .cursor {
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            from, to { visibility: visible; }
            50% { visibility: hidden; }
        }
        /* è‡ªå®šç¾©æ¨¡æ…‹æ¡†æ¨£å¼ */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 500px;
            position: relative;
            font-family: 'Inter', sans-serif;
        }

        /* éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ•æ¨£å¼ */
        #music-control {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            cursor: pointer;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            display: none; /* åˆå§‹éš±è—ï¼Œç›´åˆ° 3D å ´æ™¯å•Ÿå‹• */
        }
    </style>
</head>
<body>

    <!-- çµ‚ç«¯æ©Ÿ (CLI) æ¨¡æ“¬è¦†è“‹å±¤ -->
    <div id="cli-overlay">
        <!-- æ–‡å­—å…§å®¹å°‡ç”± JavaScript å‹•æ…‹å¯«å…¥ -->
    </div>

    <!-- 3D å ´æ™¯å®¹å™¨ -->
    <div id="scene-container"></div>
    
    <!-- éŸ³æ¨‚æ§åˆ¶æŒ‰éˆ• -->
    <div id="music-control" onclick="toggleMusic()">
        <span id="music-status">â–¶ï¸ Play Happy Birthday</span>
    </div>

    
    <!-- ä¿¡ä»¶ Modal (é è¨­éš±è—) -->
    <div id="message-modal" class="modal" onclick="hideMessageModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="absolute top-2 right-4 text-gray-500 hover:text-gray-900 text-3xl font-bold" onclick="hideMessageModal()">&times;</button>
            <div class="p-6">
                <!-- æ¨™é¡Œå·²æ›´æ–° -->
                <h2 class="text-3xl font-bold mb-4 text-pink-600">Buon compleanno!</h2> 
                <!-- ä¿¡ä»¶å…§å®¹å·²å„ªåŒ–ï¼Œå¢åŠ æ„›å¿ƒè£é£¾ -->
                <pre id="letter-content" class="text-gray-800 whitespace-pre-wrap leading-relaxed text-base">
ğŸ’– Mavi, happy birthday! ğŸ‚

Iâ€™m really happy that this is the second year I get to celebrate your birthday with you. This time, I tried a way of celebrating that I never would have imagined myself doing, and I hope it makes you happy. Iâ€™ll celebrate your birthday with you every year.

I love you. â¤ï¸

â€” å¾å£«ç”° 14.12.2025</pre>
            </div>
        </div>
    </div>

    <!-- èŠ±æŸ Modal (é è¨­éš±è—) -->
    <div id="flower-modal" class="modal" onclick="hideFlowerModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="absolute top-2 right-4 text-gray-500 hover:text-gray-900 text-3xl font-bold" onclick="hideFlowerModal()">&times;</button>
            <div class="p-6 text-center">
                <p class="text-5xl mb-4">ğŸ’</p>
                <h2 class="text-2xl font-bold mb-4 text-green-600">Flower Delivery Alert!</h2>
                <p class="text-gray-800 text-lg">
                    Your flowers are about to arrive. Please keep an eye out for a phone notificationâ¤ï¸
                </p>
            </div>
        </div>
    </div>

    <script>
        // è¨­å®šå…¨åŸŸè®Šæ•¸
        let scene, camera, renderer, table, card, flowersHitbox, cakeHitbox;
        let cardFlipGroup; // å¼•ç”¨å¡ç‰‡ç¿»è½‰çµ„ä»¶
        // äº’å‹•æ§åˆ¶è®Šæ•¸
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        // åˆå§‹æ—‹è½‰è§’åº¦èª¿æ•´: è®“è¦–è§’å°æº–ç…§ç‰‡é–“çš„ç¸«éš™ (36åº¦ï¼Œæˆ– PI * 2 / 10 å¼§åº¦)
        let targetRotationX = Math.PI * 2 / 10; 
        let targetRotationY = 0;
        let targetCameraDistance = 9.0; // åˆå§‹æ”å½±æ©Ÿè·é›¢ (æ”¾å¤§åˆ° 9.0)
        const MIN_DISTANCE = 3.5;
        const MAX_DISTANCE = 15.0; // èª¿æ•´æœ€å¤§è·é›¢ä»¥é©æ‡‰æ›´å¤§çš„å ´æ™¯
        let initialPinchDistance = 0; 
        let isPinching = false;
        
        const container = document.getElementById('scene-container');
        const cliOverlay = document.getElementById('cli-overlay');
        const clock = new THREE.Clock();
        
        // --- Three.js äº’å‹•è®Šæ•¸ ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // --- è Ÿç‡­/éŸ³è¨Šç›¸é—œè®Šæ•¸ ---
        let candleGroup; 
        let isCandleAnimating = false;
        const CANDLE_ANIMATION_DURATION = 5.0; // 5 ç§’å‹•ç•«
        let candleAnimationStartTime = 0;
        const FLAME_SCALE_FACTOR = 2.0; // ç«è‹—æ”¾å¤§ä¿‚æ•¸ (æ”¾å¤§ 2 å€)

        // *** æ”å½±æ©Ÿ/å¡ç‰‡å‹•ç•«è®Šæ•¸ ***
        let isCameraAnimating = true;
        const CAMERA_ANIMATION_DURATION = 3.0; // 3 ç§’å…¥å ´å‹•ç•«
        let cameraAnimationStartTime = 0;
        const CAMERA_START_DISTANCE = 15.0; // åˆå§‹é è·é›¢
        const CAMERA_START_HEIGHT = 10.0; // åˆå§‹é«˜é»
        
        let isCardFlipping = false;
        const CARD_FLIP_DURATION = 0.5; // å¡ç‰‡ç¿»è½‰ 0.5 ç§’
        let cardFlipStartTime = 0;
        const CARD_FLIP_ANGLE = Math.PI; // 180åº¦
        let cardFlipDirection = 1; // 1: ç¿»é–‹ (-180åº¦); -1: ç¿»å› (0åº¦)
        // -----------------------

        // *** è¦–è¦ºåé¥‹è®Šæ•¸ ***
        let visualFeedbackObject = null;
        let visualFeedbackStartTime = 0;
        const VISUAL_FEEDBACK_DURATION = 0.2; // 0.2 ç§’çš„å½ˆè·³/æ”¾å¤§æ™‚é–“
        const VISUAL_FEEDBACK_SCALE = 1.05; // æ”¾å¤§ 5%
        // -----------------------

        // *** éŸ³æ¨‚æ§åˆ¶è®Šæ•¸ (Tone.js) ***
        let synth;
        let musicSequence;
        let musicPlaying = false;
        // ----------------------------

        // ç”¨æ–¼æ¨¡æ“¬å½±ç‰‡ä¸­çš„ CLI æ•ˆæœ
        const cliScript = [
            { text: "> Mavi", delay: 500 }, 
            { text: "> today is your birthday", delay: 1000 },
            { text: "> and because Iâ€™m in the military and canâ€™t see you", delay: 1500 },
            { text: "> so i made you this computer program", delay: 1500 },
            { text: "> (à¹‘â—•â€¿â—•à¹‘) (^o^)/ (à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆ", delay: 500 },
            { text: "\n\n[Loading 3D render...] ", delay: 500 },
            { text: "   [COMPILING] modules/cake.js... OK", delay: 50 },
            { text: "   [COMPILING] modules/photos.js... OK", delay: 50 },
            { text: "   [COMPILING] modules/audio.js... OK", delay: 50 },
            { text: "\n   [EXECUTING] final build:", delay: 500 }
        ];

        // 3D æ¨¡å‹çš„åƒæ•¸
        const CAKE_HEIGHT = 1.0;
        const CAKE_RADIUS = 0.6;
        const CAKE_COLOR_1 = 0xff6b81; // ç²‰è‰²
        const CAKE_COLOR_2 = 0xfeca57; // å¥¶æ²¹é»ƒ
        const CAKE_COLOR_3 = 0xffffff; // ç™½è‰²
        const CAKE_TOP_WORLD_Y = 0.9; // è›‹ç³•é ‚éƒ¨åœ¨ä¸–ç•Œåº§æ¨™ä¸­çš„ Y ä½ç½®

        // --- éŸ³æ¨‚é‚è¼¯ ---
        function initMusic() {
            // å‰µå»ºä¸€å€‹æŸ”å’Œçš„åˆæˆå™¨ï¼Œç”¨æ–¼èƒŒæ™¯éŸ³æ¨‚
            synth = new Tone.PolySynth(Tone.Synth, {
                 oscillator: { type: "square" },
                 envelope: {
                    attack: 0.1,
                    decay: 0.2,
                    sustain: 0.5,
                    release: 1.0
                },
                volume: -15 // é™ä½éŸ³é‡
            }).toDestination();
            
            // ç”Ÿæ—¥å¿«æ¨‚æ­Œçš„æ—‹å¾‹ (åªä½¿ç”¨éŸ³ç¬¦ï¼ŒTone.Sequence æœƒè™•ç†ç¯€å¥)
            const notes = [
                "G4", "G4", "A4", "G4", "C5", "B4", null,
                "G4", "G4", "A4", "G4", "D5", "C5", null,
                "G4", "G4", "G5", "E5", "C5", "B4", "A4",
                "F5", "F5", "E5", "C5", "D5", "C5", null
            ];
            
            // ç¯€å¥å®‰æ’ (ç¢ºä¿æ¯å€‹éŸ³ç¬¦çš„æ™‚é–“é•·åº¦æ­£ç¢º)
            const divisions = [
                "8n", "8n", "4n", "4n", "4n", "4n", "4n",
                "8n", "8n", "4n", "4n", "4n", "4n", "4n",
                "8n", "8n", "4n", "4n", "4n", "4n", "4n",
                "8n", "8n", "4n", "4n", "4n", "2n"
            ];

            let noteIndex = 0;
            musicSequence = new Tone.Sequence((time, note) => {
                if (note) {
                    synth.triggerAttackRelease(note, "4n", time);
                }
            }, notes, "4n").start(0); 

            // èª¿æ•´æ™‚é–“è»¸å’Œé€Ÿåº¦
            Tone.Transport.bpm.value = 100; 
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = '6m'; 
            
            // ç”±æ–¼ç”¨æˆ¶å¿…é ˆå…ˆäº’å‹•æ‰èƒ½å•Ÿå‹• AudioContextï¼Œæˆ‘å€‘åœ¨åˆå§‹åŒ–æ™‚å…ˆæš«åœ
            Tone.Transport.pause();
        }

        function toggleMusic() {
            if (!synth) {
                initMusic();
            }
            // ç¢ºä¿ AudioContext å•Ÿå‹•
            Tone.start();

            if (musicPlaying) {
                // åœæ­¢éŸ³æ¨‚
                Tone.Transport.pause();
                document.getElementById('music-status').textContent = 'â–¶ï¸ Play Happy Birthday';
            } else {
                // æ’­æ”¾éŸ³æ¨‚
                Tone.Transport.start();
                document.getElementById('music-status').textContent = 'â¸ï¸ Pause Happy Birthday';
            }
            musicPlaying = !musicPlaying;
        }
        
        // --- Modal å‡½å¼ (ä¿æŒä¸è®Š) ---
        function showMessageModal() {
            document.getElementById('message-modal').style.display = 'flex';
        }

        function hideMessageModal() {
            document.getElementById('message-modal').style.display = 'none';
            // é—œé–‰ Modal æ™‚ï¼Œè§¸ç™¼ç¿»å›å‹•ç•«
            if (cardFlipGroup && Math.abs(cardFlipGroup.rotation.z - (-CARD_FLIP_ANGLE)) < 0.1) {
                 cardFlipDirection = -1; // è¨­ç½®ç¿»å›æ–¹å‘
                 isCardFlipping = true;
                 cardFlipStartTime = clock.getElapsedTime();
            }
        }

        function showFlowerModal() {
            document.getElementById('flower-modal').style.display = 'flex';
        }

        function hideFlowerModal() {
            document.getElementById('flower-modal').style.display = 'none';
        }
        // --- /Modal å‡½å¼ ---


        // å•Ÿå‹• CLI å‹•ç•«
        async function startCLI() {
            let fullText = '';
            for (const item of cliScript) {
                // æ¸…é™¤å‰ä¸€å€‹æ¸¸æ¨™
                cliOverlay.innerHTML = fullText.replace('<span class="cursor">_</span>', '');

                // æ¨¡æ“¬è¼¸å…¥æ•ˆæœ
                for (let i = 0; i < item.text.length; i++) {
                    fullText += item.text[i];
                    cliOverlay.innerHTML = fullText + '<span class="cursor">_</span>';
                    await new Promise(resolve => setTimeout(resolve, 30)); // æ‰“å­—é€Ÿåº¦
                }
                
                // æš«åœ
                await new Promise(resolve => setTimeout(resolve, item.delay));
                fullText += '\n';
            }
            
            // *** æ¨¡æ“¬é€²åº¦æ¢å‹•ç•« ***
            let progressBar = '   [....................] 0%';
            let progressElement = document.createElement('div');
            progressElement.id = 'progress-bar';
            progressElement.style.whiteSpace = 'pre';
            cliOverlay.appendChild(progressElement);

            for (let p = 0; p <= 100; p += 5) {
                const filled = Math.floor(p / 5);
                const empty = 20 - filled;
                
                progressBar = `   [${'#'.repeat(filled)}${'.'.repeat(empty)}] ${p}%`;
                progressElement.textContent = progressBar;
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // æœ€çµ‚ç‹€æ…‹
            progressElement.textContent = '   [####################] 100% COMPLETE';
            await new Promise(resolve => setTimeout(resolve, 500));
            // ************************


            // CLI çµæŸï¼Œé¡¯ç¤º 3D å ´æ™¯
            cliOverlay.style.display = 'none';
            container.style.display = 'block';
            document.getElementById('music-control').style.display = 'block'; // é¡¯ç¤ºéŸ³æ¨‚æ§åˆ¶æŒ‰éˆ•
            
            initScene();
            
            // *** å•Ÿå‹•æ”å½±æ©Ÿå‹•ç•« ***
            cameraAnimationStartTime = clock.getElapsedTime();
            isCameraAnimating = true;
            
            animate();
        }

        // è½‰æ› Base64 å­—ä¸²åˆ° ArrayBuffer (for WAV file creation)
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // PCM æ•¸æ“šè½‰æ›ç‚º WAV Blob (ç”¨æ–¼æ’­æ”¾ TTS éŸ³è¨Š)
        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // Int16

            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);

            // WAV header
            let offset = 0;

            // RIFF chunk
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcmData.byteLength, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;

            // fmt chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;
            view.setUint16(offset, 1, true); offset += 2; // Audio format (1 = PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; // Byte rate
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; // Block align
            view.setUint16(offset, bytesPerSample * 8, true); offset += 2; // Bits per sample

            // data chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcmData.byteLength, true); offset += 4;

            // Write PCM data
            const pcmBytes = new Uint8Array(pcmData.buffer);
            for (let i = 0; i < pcmData.byteLength; i++) {
                view.setUint8(offset + i, pcmBytes[i]);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // æ’­æ”¾ç”Ÿæ—¥æ­Œçš„ TTS èªéŸ³ (ç¾©å¤§åˆ©èª)
        async function playBirthdaySong() {
            // ç¾©å¤§åˆ©èªç¥ç¦: "Buon compleanno, Mavi!"
            const ttsPrompt = "Buon compleanno, Mavi!"; 
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: ttsPrompt }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Achird" } // é¸æ“‡ä¸€å€‹å‹å–„çš„è²éŸ³ï¼Œç¾©å¤§åˆ©èª
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            let audioUrl = null;
            let retries = 0;
            const maxRetries = 3;
            let delay = 1000;

            while (retries < maxRetries) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                        // å¾ MIME é¡å‹ä¸­è§£ææ¡æ¨£ç‡ (e.g., audio/L16;rate=24000)
                        const match = mimeType.match(/rate=(\d+)/);
                        const sampleRate = match ? parseInt(match[1], 10) : 24000;

                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        audioUrl = URL.createObjectURL(wavBlob);
                        break; // æˆåŠŸç²å–ï¼Œè·³å‡ºè¿´åœˆ
                    } else {
                        console.error("TTS Response missing audio data or invalid MIME type:", mimeType);
                    }
                } catch (error) {
                    retries++;
                    console.error(`TTS API call failed (Attempt ${retries}):`, error);
                    if (retries < maxRetries) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // æŒ‡æ•¸é€€é¿
                    }
                }
            }

            if (audioUrl) {
                const audio = new Audio(audioUrl);
                audio.play().catch(e => console.error("Error playing audio:", e));
            } else {
                console.error("Failed to generate and play TTS audio after multiple retries.");
            }
        }


        // åˆå§‹åŒ– 3D å ´æ™¯
        function initScene() {
            // 1. Scene setup
            scene = new THREE.Scene();

            // 2. Camera setup 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // åˆå§‹æ”å½±æ©Ÿä½ç½®è¨­ç½®ç‚ºé è™•çš„èµ·é»
            const initialDistance = targetCameraDistance;
            const initialX = initialDistance * Math.sin(targetRotationX) * Math.cos(targetRotationY);
            const initialZ = initialDistance * Math.cos(targetRotationX) * Math.cos(targetRotationY);
            const initialY = 0.75 + initialDistance * Math.sin(targetRotationY); // Y è»¸é–å®šåœ¨ 0.75 é«˜åº¦ç’°ç¹

            camera.position.set(initialX, initialY, initialZ);
            camera.lookAt(new THREE.Vector3(0, 0.75, 0)); // é–å®šè¦–è§’åœ¨è›‹ç³•ä¸­å¿ƒ
            
            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e); 
            container.appendChild(renderer.domElement);
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1.5, 100);
            pointLight.position.set(0, 5, 2);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.camera.near = 0.5;
            pointLight.shadow.camera.far = 50;
            scene.add(pointLight);

            // 5. Build the Scene Objects
            addBackground(); 
            addTable(); 
            addCake(); 
            addPhotoFrames(); // åœ–ç‰‡å¹³é¢ï¼Œå°ºå¯¸æ”¾å¤§ 3 å€
            addCard(); // å¡ç‰‡ç¿»è½‰é‚è¼¯å·²æ›´æ–°
            addFlowers(); // æ–°å¢èŠ±æŸ

            // 6. Event Listeners for interaction (æ¢å¾©è‡ªå®šç¾©äº‹ä»¶è™•ç†å™¨)
            window.addEventListener('resize', onWindowResize, false);
            container.addEventListener('mousedown', onMouseDown, false);
            container.addEventListener('mousemove', onMouseMove, false);
            container.addEventListener('mouseup', onMouseUp, false);
            
            container.addEventListener('wheel', onMouseWheel, false);
            
            container.addEventListener('touchstart', onTouchStart, false);
            container.addEventListener('touchmove', onTouchMove, false);
            container.addEventListener('touchend', onTouchEnd, false); 
        }
        
        // --- ç¸®æ”¾/ç’°ç¹è¨ˆç®— (æ¢å¾©è‡ªå®šç¾©é‚è¼¯) ---

        function onMouseWheel(event) {
            event.preventDefault(); 
            const zoomSpeed = 0.005; 
            targetCameraDistance += event.deltaY * zoomSpeed;
            targetCameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, targetCameraDistance));
        }
        
        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onTouchStart(event) {
            if (event.touches.length === 2) {
                isPinching = true;
                initialPinchDistance = getTouchDistance(event.touches);
            } else if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                mouseDownTime = performance.now();
            }
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 2) {
                event.preventDefault(); 
                const currentPinchDistance = getTouchDistance(event.touches);
                const deltaDistance = currentPinchDistance - initialPinchDistance;
                const pinchZoomSpeed = 0.01; 
                targetCameraDistance -= deltaDistance * pinchZoomSpeed; 

                targetCameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, targetCameraDistance));
                initialPinchDistance = currentPinchDistance;
                isDragging = false; 
            } else if (event.touches.length === 1 && isDragging) {
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                const rotationSpeed = 0.01; 
                targetRotationX += deltaX * rotationSpeed;
                targetRotationY = Math.max(-0.5, Math.min(0.5, targetRotationY + deltaY * rotationSpeed));

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }
        
        // --- /ç¸®æ”¾äº‹ä»¶è™•ç† ---


        // --- é»æ“Šäº‹ä»¶è™•ç† ---

        let mouseDownTime = 0;
        const clickThreshold = 200; // æ¯«ç§’

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
            mouseDownTime = performance.now();
        }

        function onMouseUp(event) {
            if (isDragging && (performance.now() - mouseDownTime < clickThreshold)) {
                checkIntersection(event.clientX, event.clientY);
            }
            isDragging = false;
        }

        function onTouchEnd(event) {
            if (!isPinching && isDragging && (performance.now() - mouseDownTime < clickThreshold)) {
                const clientX = event.changedTouches?.[0]?.clientX || previousMousePosition.x;
                const clientY = event.changedTouches?.[0]?.clientY || previousMousePosition.y;
                checkIntersection(clientX, clientY);
            }
            isDragging = false;
            isPinching = false;
        }

        function checkIntersection(clientX, clientY) {
            // é»æ“Šæ™‚ï¼Œå¦‚æœå¡ç‰‡æ­£åœ¨ç¿»è½‰ï¼Œå‰‡å¿½ç•¥é»æ“Š
            if (isCardFlipping) return; 

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersectableObjects = [];
            if (card) intersectableObjects.push(card); 
            if (flowersHitbox) intersectableObjects.push(flowersHitbox);
            if (cakeHitbox) intersectableObjects.push(cakeHitbox); 

            const intersects = raycaster.intersectObjects(intersectableObjects);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;

                // *** è§¸ç™¼è¦–è¦ºåé¥‹ ***
                let targetGroup = null;
                
                if (intersectedObject.name === 'birthday_card') {
                    targetGroup = cardFlipGroup; 
                    // *** è§¸ç™¼ç¿»è½‰é‚è¼¯ (ç¿»é–‹) ***
                    cardFlipDirection = 1; 
                    isCardFlipping = true;
                    cardFlipStartTime = clock.getElapsedTime();
                } else if (intersectedObject === flowersHitbox) {
                    targetGroup = intersectedObject.parent; 
                    showFlowerModal(); 
                } else if (intersectedObject === cakeHitbox) {
                    targetGroup = cake; 
                    playBirthdaySong();
                }

                if (targetGroup) {
                    // è§¸ç™¼è¦–è¦ºåé¥‹
                    visualFeedbackObject = targetGroup; 
                    visualFeedbackStartTime = clock.getElapsedTime();
                }
            }
        }
        
        // --- /é»æ“Šäº‹ä»¶è™•ç† ---

        // --- è Ÿç‡­ç‰©ä»¶å‰µå»ºèˆ‡å‹•ç•«è¨­å®š ---

        function buildSingleCandle() {
            const candle = new THREE.Group();
            const waxColor = 0xCCCCCC;
            const flameColor = 0xFF7F00;
            
            // è Ÿç‡­æœ¬é«”
            const waxGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const waxMaterial = new THREE.MeshStandardMaterial({ color: waxColor, castShadow: true }); 
            const wax = new THREE.Mesh(waxGeometry, waxMaterial);
            wax.position.set(0, 0.25, 0); 
            wax.castShadow = true;
            candle.add(wax);
            
            // ç«ç„°å¹¾ä½•é«” (åŠå¾‘ç‚º 0.02 * 2.0 = 0.04)
            const FLAME_RADIUS = 0.02 * FLAME_SCALE_FACTOR; 
            const flameGeometry = new THREE.SphereGeometry(FLAME_RADIUS, 8, 8); 
            const flameMaterial = new THREE.MeshBasicMaterial({ color: flameColor, transparent: true, opacity: 0.8 });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 0.5, 0); 
            flame.name = `candle_flame_0`;
            candle.add(flame);
            
            // ç«ç„°å…‰æº (åŸºç¤å¼·åº¦ç‚º 0.5 * 2.0 = 1.0)
            const LIGHT_INTENSITY = 0.5 * FLAME_SCALE_FACTOR; 
            const light = new THREE.PointLight(flameColor, LIGHT_INTENSITY, 2.0); 
            light.position.set(0, 0.5, 0);
            light.name = `candle_light_0`;
            light.castShadow = true; 
            candle.add(light);
            
            // åˆå§‹ç‹€æ…‹ï¼šéš±è—ç«è‹—
            flame.visible = false;
            light.visible = false;

            return candle;
        }

        function createAndAnimateCandle() {
            const CAKE_TOP_WORLD_Y = 0.9;
            candleGroup = buildSingleCandle();
            candleGroup.userData.isLit = false;
            const finalPosition = new THREE.Vector3(0, CAKE_TOP_WORLD_Y, 0);
            const startPosition = new THREE.Vector3(0, 7, 0); 

            candleGroup.userData.startPos = startPosition;
            candleGroup.userData.endPos = finalPosition;
            candleGroup.position.copy(startPosition);
            
            scene.add(candleGroup);
            isCandleAnimating = true;
            candleAnimationStartTime = clock.getElapsedTime();
        }

        // --- å ´æ™¯ç‰©ä»¶å‰µå»ºå‡½å¼ ---

        function addBackground() {
            const geometry = new THREE.SphereGeometry(30, 60, 40);
            geometry.scale(-1, 1, 1); 
            const material = new THREE.MeshBasicMaterial({
                color: 0x000033, 
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.98,
            });

            const backgroundMesh = new THREE.Mesh(geometry, material);
            scene.add(backgroundMesh);
            
            const vertices = [];
            const colors = [];
            const starCount = 500;
            const starDistance = 25;
            
            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(starDistance * 2);
                const y = THREE.MathUtils.randFloatSpread(starDistance * 2);
                const z = THREE.MathUtils.randFloatSpread(starDistance * 2);
                
                if (new THREE.Vector3(x, y, z).length() < starDistance) {
                    vertices.push(x, y, z);
                    const color = new THREE.Color(0.8 + Math.random() * 0.2, 0.8 + Math.random() * 0.2, 1);
                    colors.push(color.r, color.g, color.b);
                }
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.1,
                sizeAttenuation: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                vertexColors: true 
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function addTable() {
            const size = 10;
            const divisions = 20; 
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            
            const color1 = '#ffffff'; 
            const color2 = '#333333'; 
            const color3 = '#888888'; 

            context.fillStyle = color1; context.fillRect(0, 0, size/2, size/2);
            context.fillStyle = color2; context.fillRect(size/2, 0, size/2, size/2);
            context.fillStyle = color3; context.fillRect(0, size/2, size/2, size/2);
            context.fillStyle = color2; context.fillRect(size/2, size/2, size/2, size/2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(divisions, divisions);
            texture.encoding = THREE.sRGBEncoding;

            const geometry = new THREE.CylinderGeometry(5, 5, 0.1, 64);
            const material = new THREE.MeshStandardMaterial({ map: texture, receiveShadow: true }); 
            table = new THREE.Mesh(geometry, material);
            table.position.y = -0.05;
            table.receiveShadow = true;
            scene.add(table);
        }
        
        function addCake() {
            const CAKE_RADIUS = 0.6;
            const CAKE_COLOR_1 = 0xff6b81; 
            const CAKE_COLOR_2 = 0xfeca57; 
            const CAKE_COLOR_3 = 0xffffff; 
            
            cake = new THREE.Group();
            cake.position.y = 0.05; 
            cake.name = 'cake_group'; // çµ¦äºˆåç¨±ä»¥ä¾¿åœ¨å‹•ç•«ä¸­å¼•ç”¨
            cake.userData.initialY = cake.position.y; // è¨˜éŒ„åˆå§‹ Y ä½ç½®ï¼Œç”¨æ–¼å½ˆè·³åé¥‹

            // è›‹ç³•çµæ§‹å¸¸é‡
            const CAKE_RADIUS_BASE = CAKE_RADIUS + 0.1; // 0.7
            const CAKE_RADIUS_TOP = CAKE_RADIUS * 0.7;  // 0.42
            const CAKE_HEIGHT_BASE = 0.5;
            const CAKE_HEIGHT_TOP = 0.4;
            const STRAWBERRY_Y_POS = CAKE_HEIGHT_BASE + CAKE_HEIGHT_TOP - 0.1;

            // 1. åº•éƒ¨å¤§è›‹ç³• (ç´…è‰²å±¤)
            const baseGeometry = new THREE.CylinderGeometry(CAKE_RADIUS_BASE, CAKE_RADIUS_BASE, CAKE_HEIGHT_BASE, 32);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: CAKE_COLOR_1, castShadow: true }); 
            const baseCake = new THREE.Mesh(baseGeometry, baseMaterial);
            baseCake.position.y = CAKE_HEIGHT_BASE / 2;
            baseCake.castShadow = true;
            baseCake.receiveShadow = true;
            cake.add(baseCake);
            
            // --- ç²¾ç·»è£é£¾ START ---

            // 1.1 åº•éƒ¨èŠ±é‚Š (ç™½è‰²)
            const lowerPipingGeo = new THREE.TorusGeometry(CAKE_RADIUS_BASE, 0.03, 16, 100);
            const lowerPipingMat = new THREE.MeshStandardMaterial({ color: CAKE_COLOR_3, castShadow: true });
            const lowerPiping = new THREE.Mesh(lowerPipingGeo, lowerPipingMat);
            lowerPiping.rotation.x = Math.PI / 2;
            lowerPiping.position.y = 0; 
            lowerPiping.castShadow = true;
            cake.add(lowerPiping);

            // 1.2 å‚ç›´æ¢ç´‹ (æ·±ç²‰è‰²)
            const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0055, castShadow: true }); // Darker Pink/Red
            const numStripes = 40;
            for (let i = 0; i < numStripes; i++) {
                const stripeGeo = new THREE.BoxGeometry(0.02, CAKE_HEIGHT_BASE * 0.9, 0.01);
                const stripe = new THREE.Mesh(stripeGeo, stripeMaterial);
                
                const angle = (i / numStripes) * Math.PI * 2;
                const radius = CAKE_RADIUS_BASE * 0.99;
                
                stripe.position.x = Math.sin(angle) * radius;
                stripe.position.z = Math.cos(angle) * radius;
                stripe.position.y = CAKE_HEIGHT_BASE / 2;
                stripe.rotation.y = -angle;
                
                stripe.castShadow = true;
                cake.add(stripe);
            }
            // --- ç²¾ç·»è£é£¾ END ---


            // 2. é ‚éƒ¨å°è›‹ç³• (å¥¶æ²¹é»ƒå±¤)
            const topGeometry = new THREE.CylinderGeometry(CAKE_RADIUS_TOP, CAKE_RADIUS_TOP, CAKE_HEIGHT_TOP, 32);
            const topMaterial = new THREE.MeshStandardMaterial({ color: CAKE_COLOR_2, castShadow: true });
            const topCake = new THREE.Mesh(topGeometry, topMaterial);
            topCake.position.y = CAKE_HEIGHT_BASE + (CAKE_HEIGHT_TOP / 2); 
            topCake.castShadow = true;
            topCake.receiveShadow = true;
            cake.add(topCake);

            // 3. ä¸­é–“å¥¶æ²¹è£é£¾ (ç™½)
            const frostingGeometry = new THREE.TorusGeometry(CAKE_RADIUS_BASE * 0.98, 0.05, 16, 100);
            const frostingMaterial = new THREE.MeshStandardMaterial({ color: CAKE_COLOR_3, castShadow: true });
            const frosting = new THREE.Mesh(frostingGeometry, frostingMaterial);
            frosting.rotation.x = Math.PI / 2;
            frosting.position.y = CAKE_HEIGHT_BASE;
            frosting.castShadow = true;
            cake.add(frosting);
            
            // 3.1 é ‚å±¤å¥¶æ²¹èŠ±é‚Š (ç²‰è‰²)
            const topPipingGeo = new THREE.TorusGeometry(CAKE_RADIUS_TOP * 0.98, 0.04, 16, 100);
            const topPipingMat = new THREE.MeshStandardMaterial({ color: CAKE_COLOR_1, castShadow: true }); 
            const topPiping = new THREE.Mesh(topPipingGeo, topPipingMat);
            topPiping.rotation.x = Math.PI / 2;
            topPiping.position.y = CAKE_HEIGHT_BASE + CAKE_HEIGHT_TOP; 
            topPiping.castShadow = true;
            cake.add(topPiping);

            // 4. é ‚éƒ¨è‰è“ 
            const strawberryBaseGeo = new THREE.ConeGeometry(0.15, 0.2, 8);
            const strawberryBaseMat = new THREE.MeshStandardMaterial({ color: 0xff0000, castShadow: true });
            const strawberryBase = new THREE.Mesh(strawberryBaseGeo, strawberryBaseMat);
            strawberryBase.position.set(0, STRAWBERRY_Y_POS, 0); 
            strawberryBase.castShadow = true;
            cake.add(strawberryBase);
            
            // 4.1 è‰è“è‘‰å­ (ç¶ è‰²å¹³é¢)
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00, side: THREE.DoubleSide });
            for (let i = 0; i < 4; i++) {
                const leafGeo = new THREE.PlaneGeometry(0.1, 0.1);
                const leaf = new THREE.Mesh(leafGeo, leafMaterial);
                const angle = (i / 4) * Math.PI * 2;
                
                leaf.position.x = Math.sin(angle) * 0.08;
                leaf.position.z = Math.cos(angle) * 0.08;
                leaf.position.y = STRAWBERRY_Y_POS - 0.05;
                
                leaf.rotation.x = Math.PI / 2;
                leaf.rotation.z = angle;
                
                leaf.castShadow = true;
                cake.add(leaf);
            }
            
            // 5. *** é»æ“Šåµæ¸¬ç”¨çš„éš±å½¢ç¢°æ’ç®± ***
            const hitboxGeometry = new THREE.CylinderGeometry(CAKE_RADIUS_BASE, CAKE_RADIUS_BASE, 1.5, 32);
            const hitboxMaterial = new THREE.MeshBasicMaterial({ visible: false });
            cakeHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial); // è¨­ç‚ºå…¨åŸŸè®Šæ•¸
            cakeHitbox.position.y = 0.75;
            cakeHitbox.name = 'cake_hitbox'; 
            cake.add(cakeHitbox);

            scene.add(cake);
            
            createAndAnimateCandle();
        }
        
        function addPhotoFrames() {
            const frameGroup = new THREE.Group();
            
            // 5 å¼µçœŸå¯¦åœ–ç‰‡ URL
            const photoUrls = [
                'https://i.imgur.com/xKUIgm2.jpeg',
                'https://i.imgur.com/UknecWI.jpeg',
                'https://i.imgur.com/Fn5wVyx.jpeg',
                'https://i.imgur.com/mjJI2zI.jpeg',
                'https://i.imgur.com/Q7bW7VZ.jpeg'
            ];

            // åœ–ç‰‡å°ºå¯¸å’Œè·é›¢æ”¾å¤§ 3 å€
            const frameDistance = 7.5; 
            const photoWidth = 1.5;   
            const photoHeight = 1.05; 
            const numFrames = 5; 

            // å‚ç›´ä½ç½®ï¼šè®“åœ–ç‰‡åº•éƒ¨æ›´é è¿‘æ¡Œå­ (Y=0)
            const imageYPosition = photoHeight / 2 + 0.01; 

            for (let i = 0; i < numFrames; i++) {
                const angle = (i / numFrames) * Math.PI * 2; 
                const x = Math.sin(angle) * frameDistance;
                const z = Math.cos(angle) * frameDistance;
                
                // 1. åœ–ç‰‡ (ä½¿ç”¨ Image() å°è±¡å’Œ THREE.Texture)
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = photoUrls[i];
                
                // å‰µå»ºä¸€å€‹åŸºç¤æè³ª (é è¨­ç‚ºç™½è‰²ï¼Œä½œç‚ºå›é€€)ã€‚é€™è£¡ä½¿ç”¨ MeshStandardMaterial ä¾†åƒèˆ‡å…‰ç…§ï¼Œå¢åŠ çœŸå¯¦æ„Ÿã€‚
                let photoMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide, roughness: 0.8, metalness: 0.1 });
                
                img.onload = () => {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    texture.encoding = THREE.sRGBEncoding;

                    photoMaterial.map = texture;
                    photoMaterial.needsUpdate = true;
                    console.log(`Photo ${i + 1} loaded successfully.`);
                };

                img.onerror = (error) => {
                    console.error(`Error loading Imgur photo ${i + 1}. Fallback to white color.`, error);
                };
                
                const photoGeometry = new THREE.PlaneGeometry(photoWidth, photoHeight);
                const photo = new THREE.Mesh(photoGeometry, photoMaterial);
                
                photo.position.set(x, imageYPosition, z); 
                photo.rotation.y = angle + Math.PI; 
                photo.castShadow = true;
                photo.receiveShadow = true;
                frameGroup.add(photo);
            }

            scene.add(frameGroup);
        }

        function addFlowers() {
            const flowerGroup = new THREE.Group();
            flowerGroup.name = 'flower_group';
            
            const FLOWER_POS_X = -3.0; 
            const FLOWER_POS_Z = 0.0;
            const VASE_HEIGHT = 0.6;
            
            flowerGroup.position.set(FLOWER_POS_X, 0.05, FLOWER_POS_Z); 
            flowerGroup.userData.initialScale = 1; // è¨˜éŒ„åˆå§‹æ¯”ä¾‹ï¼Œç”¨æ–¼å½ˆè·³åé¥‹

            // 1. èŠ±ç“¶ (åœ“æŸ±é«”)
            const vaseGeometry = new THREE.CylinderGeometry(0.2, 0.15, VASE_HEIGHT, 16);
            const vaseMaterial = new THREE.MeshStandardMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.8, castShadow: true });
            const vase = new THREE.Mesh(vaseGeometry, vaseMaterial);
            vase.position.y = VASE_HEIGHT / 2; 
            vase.castShadow = true;
            flowerGroup.add(vase);

            // 2. æ¨¡æ“¬èŠ±æœµ (ç°¡å–®çš„çƒé«”)
            const flowerPositions = [
                { x: 0.1, z: 0.0, color: 0xFF1493 }, 
                { x: -0.1, z: 0.1, color: 0xFF69B4 },
                { x: 0.05, z: -0.15, color: 0xFF0000 },
                { x: -0.15, z: -0.05, color: 0xFF4500 } 
            ];
            const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, castShadow: true }); 

            flowerPositions.forEach(pos => {
                const petalGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const petalMaterial = new THREE.MeshStandardMaterial({ color: pos.color, castShadow: true }); 
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.set(pos.x, VASE_HEIGHT + 0.3, pos.z); 
                petal.castShadow = true;
                flowerGroup.add(petal);

                const stemGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 4);
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.set(pos.x * 0.5, VASE_HEIGHT + 0.15, pos.z * 0.5);
                stem.rotation.x = Math.PI / 8; 
                stem.castShadow = true;
                flowerGroup.add(stem);
            });
            
            // 3. é»æ“Šåµæ¸¬å€åŸŸ (éš±å½¢ç«‹æ–¹é«”)
            const hitboxGeometry = new THREE.BoxGeometry(0.5, 1.2, 0.5); 
            const hitboxMaterial = new THREE.MeshBasicMaterial({ visible: false }); 
            flowersHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            flowersHitbox.position.y = VASE_HEIGHT / 2 + 0.3; 
            flowersHitbox.name = 'flower_hitbox';
            
            flowersHitbox.userData.initialScale = 1;
            flowerGroup.add(flowersHitbox);
            scene.add(flowerGroup);
        }

        function addCard() {
            const CARD_WIDTH = 0.8;
            const CARD_HEIGHT = 0.6;
            const CARD_Y_OFFSET = 0.01;
            const CARD_X = 3.0;
            const CARD_Z = 0.0;
            
            // cardFlipGroup æ˜¯æˆ‘å€‘å¯¦éš›é»æ“Šå’Œç¿»è½‰çš„å°è±¡
            cardFlipGroup = new THREE.Group();
            cardFlipGroup.position.set(CARD_X, CARD_Y_OFFSET, CARD_Z);
            cardFlipGroup.rotation.x = -Math.PI / 2; // å¹³æ”¾åœ¨æ¡Œä¸Š (ç¹ X è»¸æ—‹è½‰ -90 åº¦)
            cardFlipGroup.name = 'card_flip_group';
            cardFlipGroup.userData.initialScale = 1; // ç”¨æ–¼é»æ“Šè¦–è¦ºåé¥‹
            
            // 1. å¡ç‰‡å°é¢ (å¯é»æ“Šçš„è¡¨é¢)
            const coverTexture = new THREE.TextureLoader().load(
                'https://placehold.co/400x300/FFDDC1/000000?text=Happy+Birthday%5C%0A+%E8%A6%AA%E6%84%9B%E7%9A%84+Mavi%5C%0A+%E9%BB%9E%E6%93%8A%E7%9C%8B%E4%BF%A1%E4%BB%B6%EF%BC%81', 
                (texture) => { texture.encoding = THREE.sRGBEncoding; }
            );
            const coverMaterial = new THREE.MeshBasicMaterial({ map: coverTexture, side: THREE.DoubleSide });
            const coverGeometry = new THREE.PlaneGeometry(CARD_WIDTH, CARD_HEIGHT);
            
            // *** èª¿æ•´å¹¾ä½•é«”éŒ¨é»ï¼Œä½¿å…¶ç¹è‘—é•·é‚Šçš„åº•éƒ¨é‚Šç·£æ—‹è½‰ï¼ˆZ è»¸ï¼‰ ***
            coverGeometry.translate(0, CARD_HEIGHT / 2, 0); 

            card = new THREE.Mesh(coverGeometry, coverMaterial); // *** card æ˜¯å°é¢ï¼Œç”¨æ–¼é»æ“Šåµæ¸¬ ***
            card.name = 'birthday_card';
            card.castShadow = true;
            card.receiveShadow = true;
            
            cardFlipGroup.add(card); 

            scene.add(cardFlipGroup);

            // æˆ‘å€‘ä½¿ç”¨ card ç‰©ä»¶æœ¬èº«ä¾†é€²è¡Œ Raycasting
        }

        // --- äº’å‹•èˆ‡å‹•ç•«å‡½å¼ ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // æ—‹è½‰æ§åˆ¶ (æ¢å¾©è‡ªå®šç¾©é‚è¼¯)
        function onMouseMove(event) {
            // ç¢ºä¿æ²’æœ‰åœ¨ç¸®æ”¾æˆ–é»æ“Š
            if (!isDragging || isPinching) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            const rotationSpeed = 0.005;

            targetRotationX += deltaX * rotationSpeed;
            targetRotationY = Math.max(-0.5, Math.min(0.5, targetRotationY + deltaY * rotationSpeed));

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onTouchMove(event) {
            if (event.touches.length === 2) {
                // é›™æŒ‡ç¸®æ”¾
                event.preventDefault(); 
                const currentPinchDistance = getTouchDistance(event.touches);
                const deltaDistance = currentPinchDistance - initialPinchDistance;
                const pinchZoomSpeed = 0.01; 
                targetCameraDistance -= deltaDistance * pinchZoomSpeed; 

                targetCameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, targetCameraDistance));
                initialPinchDistance = currentPinchDistance;
                isDragging = false; 
            } else if (event.touches.length === 1 && isDragging) {
                // å–®æŒ‡æ—‹è½‰
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                const rotationSpeed = 0.01; 
                targetRotationX += deltaX * rotationSpeed;
                targetRotationY = Math.max(-0.5, Math.min(0.5, targetRotationY + deltaY * rotationSpeed));

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // --- æ”å½±æ©Ÿå…¥å ´å‹•ç•« ---
            if (isCameraAnimating) {
                const timeElapsed = elapsedTime - cameraAnimationStartTime;
                const t = Math.min(1, timeElapsed / CAMERA_ANIMATION_DURATION);
                
                // æ”å½±æ©Ÿæœ€çµ‚ä½ç½®
                const finalDistance = targetCameraDistance;
                const finalX = finalDistance * Math.sin(targetRotationX) * Math.cos(targetRotationY);
                const finalZ = finalDistance * Math.cos(targetRotationX) * Math.cos(targetRotationY);
                const finalY = 0.75 + finalDistance * Math.sin(targetRotationY);
                
                // æ”å½±æ©Ÿèµ·å§‹ä½ç½®
                const startX = CAMERA_START_DISTANCE * Math.sin(targetRotationX);
                const startZ = CAMERA_START_DISTANCE * Math.cos(targetRotationX);
                const startY = CAMERA_START_HEIGHT;

                // LERP (ç·šæ€§æ’å€¼)
                camera.position.x = startX + (finalX - startX) * t;
                camera.position.y = startY + (finalY - startY) * t;
                camera.position.z = startZ + (finalZ - startZ) * t;

                if (t >= 1) {
                    isCameraAnimating = false;
                }
            } else {
                // --- ç¸®æ”¾/ç’°ç¹è¨ˆç®— (è‡ªå®šç¾©é‚è¼¯) ---
                const currentDistance = camera.position.distanceTo(new THREE.Vector3(0, 0.75, 0)); 
                const distance = THREE.MathUtils.lerp(currentDistance, targetCameraDistance, 0.1);

                const newX = distance * Math.sin(targetRotationX) * Math.cos(targetRotationY);
                const newZ = distance * Math.cos(targetRotationX) * Math.cos(targetRotationY);
                const newY = 0.75 + distance * Math.sin(targetRotationY); 
                
                camera.position.set(newX, newY, newZ);
            }
            
            camera.lookAt(new THREE.Vector3(0, 0.75, 0)); // å§‹çµ‚çœ‹å‘è›‹ç³•ä¸­å¿ƒ

            // --- è Ÿç‡­æ’å…¥å‹•ç•«é‚è¼¯ ---
            if (isCandleAnimating && candleGroup) {
                const timeElapsed = elapsedTime - candleAnimationStartTime;
                let t = Math.min(1, timeElapsed / CANDLE_ANIMATION_DURATION); 

                if (t < 1) {
                    candleGroup.position.lerpVectors(
                        candleGroup.userData.startPos,
                        candleGroup.userData.endPos,
                        t
                    );
                    
                } else {
                    isCandleAnimating = false;
                    
                    const flame = candleGroup.getObjectByName('candle_flame_0');
                    const light = candleGroup.getObjectByName('candle_light_0');
                    if (flame) flame.visible = true;
                    if (light) light.visible = true;
                }
            }
            // ---------------------------
            
            // *** å¡ç‰‡ç¿»è½‰å‹•ç•«é‚è¼¯ ***
            if (isCardFlipping && cardFlipGroup) {
                const timeSinceFlip = elapsedTime - cardFlipStartTime;
                const t = Math.min(1, timeSinceFlip / CARD_FLIP_DURATION);

                let targetAngle = CARD_FLIP_ANGLE * cardFlipDirection; 
                let startAngle = 0;

                if (cardFlipDirection === 1) {
                     // ç¿»é–‹ (0åº¦ åˆ° -180åº¦)
                     startAngle = 0;
                     targetAngle = -CARD_FLIP_ANGLE;
                     
                } else if (cardFlipDirection === -1) {
                    // ç¿»å› (-180åº¦ åˆ° 0åº¦)
                    startAngle = -CARD_FLIP_ANGLE;
                    targetAngle = 0;
                }

                // ç¹ Z è»¸æ—‹è½‰ (å¡ç‰‡çš„é•·é‚Š)
                cardFlipGroup.rotation.z = THREE.MathUtils.lerp(startAngle, targetAngle, t); 
                
                if (t >= 1) {
                    isCardFlipping = false;
                    
                    if (cardFlipDirection === 1) {
                         // å‹•ç•«çµæŸï¼šç¿»é–‹åˆ° -180åº¦ï¼Œé¡¯ç¤º Modal
                         cardFlipGroup.rotation.z = -CARD_FLIP_ANGLE; 
                         showMessageModal();
                    } else {
                         // å‹•ç•«çµæŸï¼šç¿»å›åˆ° 0åº¦ï¼ŒçµæŸ
                         cardFlipGroup.rotation.z = 0; 
                    }
                }
            }
            // ------------------------
            
            // *** è¦–è¦ºåé¥‹å‹•ç•«é‚è¼¯ ***
            if (visualFeedbackObject) {
                const timeSinceClick = elapsedTime - visualFeedbackStartTime;
                const t = timeSinceClick / VISUAL_FEEDBACK_DURATION; 

                if (t < 1) {
                    const bounceFactor = Math.sin(t * Math.PI) * (VISUAL_FEEDBACK_SCALE - 1.0) * 2;

                    if (visualFeedbackObject.name === 'cake_group') {
                        // è›‹ç³•ï¼šè¼•å¾®ä¸Šä¸‹è·³å‹• (å½±éŸ¿ Y ä½ç½®)
                        visualFeedbackObject.position.y = visualFeedbackObject.userData.initialY + bounceFactor * 0.15; 
                    } else {
                        // å¡ç‰‡/èŠ±æŸï¼šæ”¾å¤§/ç¸®å° (å½±éŸ¿ Scale)
                        const newScale = 1.0 + bounceFactor;
                        visualFeedbackObject.scale.set(newScale, newScale, newScale);
                    }
                } else {
                    // å‹•ç•«çµæŸï¼Œé‡è¨­ç‚ºåˆå§‹ç‹€æ…‹
                    if (visualFeedbackObject.name === 'cake_group') {
                        visualFeedbackObject.position.y = visualFeedbackObject.userData.initialY;
                    } else {
                        visualFeedbackObject.scale.set(1, 1, 1);
                    }
                    visualFeedbackObject = null; // æ¸…é™¤å¼•ç”¨
                }
            }
            // ------------------------

            // è Ÿç‡­ç«ç„°é–ƒçˆæ•ˆæœ 
            if (candleGroup) {
                const flame = candleGroup.getObjectByName('candle_flame_0');
                const light = candleGroup.getObjectByName('candle_light_0');
                if (flame && flame.visible) {
                    const flicker = Math.sin(clock.elapsedTime * 10) * 0.05; 
                    flame.scale.setScalar(FLAME_SCALE_FACTOR + flicker); 
                    
                    if (light) {
                       light.intensity = 1.0 + Math.sin(clock.elapsedTime * 5) * 0.25; 
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œå•Ÿå‹•
        window.onload = function() {
            // å•Ÿå‹• CLI æ•ˆæœ
            startCLI();
            // åˆå§‹åŒ–éŸ³æ¨‚ï¼Œä½†ä¿æŒæš«åœï¼Œç­‰å¾…ç”¨æˆ¶é»æ“Š
            initMusic(); 
        };

    </script>
</body>
</html>